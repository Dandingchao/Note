String对象除了创建一个对象实例，还会在JVM的字符串常量池中创建相同的对象
StringBuffer和Hashmap的机制类似，当超出初始化的范围时会扩容，应尽量在创建对象时确定大小，避免扩容造成的性能损耗
在做计算操作时，为了性能可以使用位移操作符替换乘除操作，当乘除的数为2的倍数时
在能使用基础类型的地方尽量使用基础类型，使用封装类型会创建新的对象，增加了系统对对象的创建和释放
尽早释放无用的引用，节约内存
尽量避免使用二维数组，二维数组存储相同数据量的数据比一位数组的内存消耗大一倍以上(原因暂未解)
因为Java中不存在二维数组，创建的二维数组事实上是一个数组，在第一个维度上存储第二个维度的引用
该引用指向该数组的第一个引用。所以创建二维数组会产生更大的开销
尽量减少对象实例的创建，增加对象的复用效率，因为创建对象会增加开销(时间和内存),同时因为对象的增加，对内存的占据增加也会导致GC更快触发消耗时间

java在对象创建完成之后对象就是固定的了，再之后你对对象进行类型转换只是使用了不同的类型引用去指g 向同一个对象
此时因为引用的不同，你只能使用引用类型暴露出来给你使用的public方法，对象的内部方法被隐藏，但仍旧存在，对象内部如果对隐藏
方法有存在调用仍旧可以调用。因此子类强制转换成父类是可行的，而父类强制转换类型为子类则无法成功，除非父类是由该子类强制类型转换
得到的

java实例对象分为三个部分，对象头（包括锁信息，8字节），类对象指针(指向该类的class类，class类保存在方法区，1.8及以后存放在堆里，大小由计算机位数决定
32位为4字节，64位为8字节)，实例数据块，填充块(java对象强制要求大小为8字节的倍数)
所以将传输后的数据如json转换成java类对象之后，被转换成的对象会增加内存的消耗

java对象头又分为三部分:
mark word(用于记录对象是否有锁或者被gc标记) 32位为32bit，64位主机为64bit
锁标志位(标志是否被锁住) 偏向锁标志位(标志是否偏向锁), 锁可以从无锁-偏向锁自由转换，但是一旦发生竞争升级为轻量级锁则不可降级，轻量级锁
CAS操作次数过多升级为重量级锁，重量级同理
重量级锁维护一个阻塞队列
指向类对象的指针
数组长度(数组对象特有)