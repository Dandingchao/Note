String对象除了创建一个对象实例，还会在JVM的字符串常量池中创建相同的对象
StringBuffer和Hashmap的机制类似，当超出初始化的范围时会扩容，应尽量在创建对象时确定大小，避免扩容造成的性能损耗
在做计算操作时，为了性能可以使用位移操作符替换乘除操作，当乘除的数为2的倍数时
在能使用基础类型的地方尽量使用基础类型，使用封装类型会创建新的对象，增加了系统对对象的创建和释放
尽早释放无用的引用，节约内存
尽量避免使用二维数组，二维数组存储相同数据量的数据比一位数组的内存消耗大一倍以上(原因暂未解)
因为Java中不存在二维数组，创建的二维数组事实上是一个数组，在第一个维度上存储第二个维度的引用
该引用指向该数组的第一个引用。所以创建二维数组会产生更大的开销
尽量减少对象实例的创建，增加对象的复用效率，因为创建对象会增加开销(时间和内存),同时因为对象的增加，对内存的占据增加也会导致GC更快触发消耗时间

java在对象创建完成之后对象就是固定的了，再之后你对对象进行类型转换只是使用了不同的类型引用去指g 向同一个对象
此时因为引用的不同，你只能使用引用类型暴露出来给你使用的public方法，对象的内部方法被隐藏，但仍旧存在，对象内部如果对隐藏
方法有存在调用仍旧可以调用。因此子类强制转换成父类是可行的，而父类强制转换类型为子类则无法成功，除非父类是由该子类强制类型转换
得到的
