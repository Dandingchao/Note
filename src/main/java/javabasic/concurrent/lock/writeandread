java中的读写锁是依旧AQS来实现的，AQS能够存储当前获取锁的线程和state，state表示加锁次数，每被加一次锁则state次数加一，同时依据不同的加锁类型
还会对读锁或写锁的状态+1.总之锁的状态非0则意味则资源被加锁，为0则表示无线程获取了这把锁。AQS用一个三十二位的整型表示加锁次数，前16位为读锁，后十六位为写锁。
AQS还存储了当前持有锁的线程如果是写锁的话，则就是独占的锁
读锁的话，采用threadlocal记录每个锁的加锁次数，获取读锁时使用CAS不断自选直到得到锁并增加重入次数

特殊的是，如果有读锁想要获取锁，他会去确认现在资源是读锁还是写锁，如果是读锁他会再去确认等待队列中是否有线程要获取写锁，如果没有则获取共享锁sharelock，
锁重入次数加一，否则进入等待队列。如果是写锁，他会确认自身是否持有这把锁，如果持有，再判断是否达到重入的最大次数，不是的话则重入次数加一，如果没有则进入等待队列
共享锁:sharedlock，读锁readlock.独占锁exclusivelock，写锁writelock