JVM java virtual machine
中文又称为爪哇虚拟机，所有java程序都是通过JVM编译运行的。JVM的优化即是通过修改JVM的内存参数，减少JAVA程序再运行过程中因为进行GC而占用的时间，增大程序的运行效率
因为JAVA的垃圾回收完全是通过在JVM上运行的守护线程-垃圾回收线程执行的，所以在java程序运行的过程中，程序员基本上是无法直接对Java程序的内存占用进行操作，要释放内存
只能通过jvm执行gc来进行内存的回收。而java的gc会占用cpu时间，所以要通过对JVM的参数进行调整，让java程序在运行中减少gc占用的时间
如果jvm的内存分配过大，那么进行一次gc会占用更多的时间，如果jvm的内存分配过小，又会导致java程序频繁的进行gc，占用更多的时间，所以适当的给jvm分配内存是优化程序运行效率的一个很重要的方式。

说到jvm的内存，就必须要说一下jvm的内存分布了，我个人比较认可的一个理解是，jvm将内存分为数据模块和逻辑运行模块。
数据模块指java的堆和元数据区(1.7即以前是永久代)，他们存储的实际上都是java运行时的数据模块信息，即你需要的数据都是从这一块区域中读取
而栈区，程序计数器，本地方法栈，这三块我认为可以看作时逻辑运行存储的数据模块。即程序运行中需要的逻辑信息都存储在这一类的区域中。

线程独有:
栈区存储了java程序运行过程中的信息(通过形成栈帧)，比如局部变量，java基础数据类型，java对象引用，java的方法出口，操作数据信息(每个方法的信息都存放在对应的栈帧里)。程序每调用一个方法，都会生成一个栈帧放进栈区，如果无限递归，会导致stackoverflow
或OOM。
程序计数器存储了当前正在执行的代码的行号，jvm通过读取执行代码的行号来确定接下来需要执行的代码是哪一段。不过执行native方法时程序计数器指向null，因为执行native方法时如何执行是native方法的事和jvm无关(占用内存小，不会OOM)
本地方法栈，为jvm提供本地方法调用的接口，让jvm在运行期间可以调用本地方法，如c/c++写的，本质上事用JIT直接调用本地方法。和普通栈区一样，会stackoverflow和OOM

线程共享：
堆区，堆区存放java的对象，堆可以分配在不连续的内存空间中，堆分为新生代，老年代。新生代存放刚创建的对象，老年代存放长时间存活对象。新生代通常按8：1：1分成三块
8存放刚创建的对象，1：1的两块用于存放在gc后仍存活的对象，存活次数超过设定的gc次数时对象转存至老年代，1：1两块一块永远为空，当另一块满后进行gc直接将存活对象复制到另一块空块中
大对象可直接在老年代中生成，为了避免gc时大对象在新生代中频繁复制(降低性能)

元空间，占用本地内存

JVM是指java virtual machine，java程序运行在这台虚拟机上
JVM调优是指通过分析JVM在运行时的数据，根据JVM的运行情况调整JVM的设置参数以此获得更好的JVM性能让程序运行的速度提升或内存利用率增大减少程序错误
堆太大会导致扫描时间过长，堆太小会导致频繁GC出现大量内存碎片
一般原则：堆大小为老年代大小的3~4倍

java工作内存模型，逻辑上Java每个线程都有自己的工作内存存储数据与主内存不同，是自己的工作中使用到变量的副本，
每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。
它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。
由于逻辑上是这样的执行方式，那么就会导致不同的线程对同一个变量进行操作时他们对变量的修改无法马上传递到主内存，而造成数据可见性的丢失。
可见性：数据被一个线程修改是否能立刻让其他线程知道该值已经被改变
原子性：操作不可被中断，即一个操作或一串操作，只能都执行成功或都执行失败，只有使用原子性操作才能保证可见性(即在并发编程中数据安全，即某个线程对共享
变量的修改能够立刻被其他线程知道，线程在对某个共享变量进行修改时，不会因为CPU中断，该值被其他线程修改而导致的程序执行出错)
有序性：由于JNT希望获得最大的运行效率，所以他可能会对将要执行的指令进行重排序(并发编程下),进行指令重排序可能会导致先进行的操作后发生，然后覆盖后执行
的操作的数据，导致数据出错。
我个人认为三个特性都是为了在多线程的情况下保证Java不同线程对数据的操作具有原子性，不让因为并发执行的顺序问题而导致数据的不一致。

JVM定义了8种操作为原子性操作，提供工作内存和主内存的交互
lock(锁定)：作用于主内存，它把一个变量标记为一条线程独占状态；
read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用；
load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；
use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；
assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；
store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；
write(写入)：作用于主内存，它把store传送值放到主内存中的变量中。
unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定；