JVM java virtual machine
中文又称为爪哇虚拟机，所有java程序都是通过JVM编译运行的。JVM的优化即是通过修改JVM的内存参数，减少JAVA程序再运行过程中因为进行GC而占用的时间，增大程序的运行效率
因为JAVA的垃圾回收完全是通过在JVM上运行的守护线程-垃圾回收线程执行的，所以在java程序运行的过程中，程序员基本上是无法直接对Java程序的内存占用进行操作，要释放内存
只能通过jvm执行gc来进行内存的回收。而java的gc会占用cpu时间，所以要通过对JVM的参数进行调整，让java程序在运行中减少gc占用的时间
如果jvm的内存分配过大，那么进行一次gc会占用更多的时间，如果jvm的内存分配过小，又会导致java程序频繁的进行gc，占用更多的时间，所以适当的给jvm分配内存是优化程序运行效率的一个很重要的方式。

说到jvm的内存，就必须要说一下jvm的内存分布了，我个人比较认可的一个理解是，jvm将内存分为数据模块和逻辑运行模块。
数据模块指java的堆和元数据区(1.7即以前是永久代)，他们存储的实际上都是java运行时的数据模块信息，即你需要的数据都是从这一块区域中读取
而栈区，程序计数器，本地方法栈，这三块我认为可以看作时逻辑运行存储的数据模块。即程序运行中需要的逻辑信息都存储在这一类的区域中。

线程独有:
栈区存储了java程序运行过程中的信息(通过形成栈帧)，比如局部变量，java基础数据类型，java对象引用，java的方法出口，操作数据信息(每个方法的信息都存放在对应的栈帧里)。程序每调用一个方法，都会生成一个栈帧放进栈区，如果无限递归，会导致stackoverflow
或OOM。
程序计数器存储了当前正在执行的代码的行号，jvm通过读取执行代码的行号来确定接下来需要执行的代码是哪一段。不过执行native方法时程序计数器指向null，因为执行native方法时如何执行是native方法的事和jvm无关(占用内存小，不会OOM)
本地方法栈，为jvm提供本地方法调用的接口，让jvm在运行期间可以调用本地方法，如c/c++写的，本质上事用JIT直接调用本地方法。和普通栈区一样，会stackoverflow和OOM

线程共享：
堆区，堆区存放java的对象，堆可以分配在不连续的内存空间中，堆分为新生代，老年代。新生代存放刚创建的对象，老年代存放长时间存活对象。新生代通常按8：1：1分成三块
8存放刚创建的对象，1：1的两块用于存放在gc后仍存活的对象，存活次数超过设定的gc次数时对象转存至老年代，1：1两块一块永远为空，当另一块满后进行gc直接将存活对象复制到另一块空块中
大对象可直接在老年代中生成，为了避免gc时大对象在新生代中频繁复制(降低性能)

元空间，占用本地内存

JVM是指java virtual machine，java程序运行在这台虚拟机上
JVM调优是指通过分析JVM在运行时的数据，根据JVM的运行情况调整JVM的设置参数以此获得更好的JVM性能让程序运行的速度提升或内存利用率增大减少程序错误
堆太大会导致扫描时间过长，堆太小会导致频繁GC出现大量内存碎片
一般原则：堆大小为老年代大小的3~4倍
