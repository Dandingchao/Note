线程池参数
消息队列消息重复处理

可重入锁:
避免获取锁的方法因为内部调用锁方法而导致的死锁。

方法一：利用数据库的唯一约束实现幂等
方法二：为更新的数据设置前置条件
方法三（建议使用此方法）： 令牌机制


full gc触发方式，频繁full gc如何检测
老年代满，手动触发system.gc()

mysql limit优化
设置索引，在搜索的时候使用上索引，（主键索引或唯一索引，唯一索引指索引值在表中唯一）
select * from table_name limit start,num;不用索引，全文搜索，数量大很慢。
达成 select * from table_name where t.pk>(pageNum*pageSize) limit pageSize;使用主键
select * from table_name where t.pk>(pageNum*pageSize) order by t.pk limit pageSize;使用主键，同时排序
可以用子查询优化
类似:
select * from orders_history where type=8 and
id>=(select id from orders_history where type=8 limit 100000,1)
limit 100;

复合索引
例，索引abc。当搜索中使用到abc，ab，a时会使用该索引。具体使用何种索引，取决于数据库对搜索优化后的结果
数据库每次搜索只有一条搜因会被使用到，同时索引遵循最左匹配原则，即使sql语句为 c==xx,b==xx,a==x,仍会使用abc索引。

redis 缓存失效的问题，经典三问，雪崩，击穿，穿透。
穿透:频繁访问不存在数据，造成访问大量打入DB，解决：布隆过滤器，缓存空对象。
击穿:热点数据缓存失效，访问大量打入DB。解决:镜像redis，设置访问锁。
雪崩:大量缓存同一时间失效。解决:缓存失效时间错开

equals() hashcode
hashcode，单纯计算对象的hash值
equals在未重写前，等价于==，比较对象地址。


concurrenthashmap
使用synchronized锁住每个单个节点。节点由链表或红黑树构成。仅当单节点个数超过8，且总结点数大于64时，重构整个链表为红黑树
减少搜索时间，n->logN

双指针问题
设计模式
分为三类：
创建类，结构类，行为类。
创建类:类的创建方式，使用不同的方法，如工厂，单例，原型，创建则模式。
结构类:类的构成模式，主要用于对类的修饰，增强。
代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

行为类:类的行为模式，比如某些类要执行某些操作，这时候使用这些设计模式可以使这些方法更清晰的被执行，开发人员更容易理解。
行为型模式用于描述程序在运行时复杂的流程控制，
即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，
它涉及算法与对象间职责的分配。

juc包工具类
countDownLatch,
CyclicBarrier,
Exchanger,
Semaphore

springcloud微服务组件
纸上谈兵:
目前实现过eureka服务注册。
五大组件：eurake-服务注册，ribbon-负载均衡(在eurake上注册同名服务，使用ribbon的话，会将请求进行负载均衡，将请求分配到负载较小的同名服务上)，
hystrix-服务容错保护(当部分请求，请求到某个服务上造成的失败过多时，hystrix会直接让请求失败而不会再将请求发送到服务上)，
feign-服务调用(直接使用feign调用eurake上注册的其他服务的方法，内部使用http请求发送，即你不需要再本地再记录其他服务的ip，你可以直接调用服务名和
服务api直接调用该服务，很方便)
zuul-api网关服务。将请求，权限等功能集成到一个模块上，zuul，让其他服务不需要担心服务请求的身份问题，而是将问题全部交给zuul来处理。


config-分布式配置中心，方便服务配置文件统一管理(看这个描述我怎么感觉这玩意和zookeeper是同样的功能)。

bus-通信工具。Spring cloud bus 通过轻量消息代理连接各个分布的节点。管理和传播所有分布式项目中的消息，本质是利用了MQ的广播机制在分布式的系统中传播消息，目前常用的有Kafka和RabbitMQ。
看描述感觉和消息队列是一样的

stream-消息驱动微服务，感觉也是消息队列的一种

sleuth-分布式服务跟踪。(没看懂什么玩意)
在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前段请求都会形成一条复杂的分布式服务调用链路，
链路中的任何一环出现高延时或错误都会引起整个请求最后的失败。

Spring Cloud Sleuth提供了一套完整的服务跟踪的解决方案。


shiro:用于身份验证，zuul用于进入系统前的屏蔽，shiro用于进入系统后的身份验证。

