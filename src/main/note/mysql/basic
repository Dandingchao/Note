mysql是写优先级更高的数据库
因此在高并发的情况下，读任务可能会因为写任务而被阻塞(解决方法：使用指令指示mysql优先执行某些读指令)

mysql查询执行逻辑：
多连接接收客户端的查询请求
查询请求有两种处理方式：查询缓存/进入解析器
查询经过解析器解析后也有两种处理方式：查询缓存/将查询语句放入查询优化器
查询优化器优化查询语句(mysql自己决定一种自认为最快的查询方式),即mysql
执行查询语句，到内存中查询需要的数据。

mysql如果拥有过多的update语句，实际上执行一次update就会使mysql全部缓存失效
即写频繁，会导致缓存频繁失效，查询时缓存命中率低
查询会生成查询缓存，在下次查询时会比对缓存，如若缓存命中则从缓存中取数据(内存)

数据库事务遵循四大特性：ACID
atomicity  consistency  isolation   durability
原子性 一致性 隔离性 持久性
原子性：事务被看成是一个单次操作，事务内的所有操作要么全部提交，要么全部不提交
一致性：事务在执行的前后，数据库必须保持在一致的状态，即在事务执行前后不允许数据发生变化
隔离性：事务在执行过程中，对于事务自身来说，他必须要认为在同时操作数据库的只有该事务，没有其他事务在和他竞争同时操作
持久性：数据的持久性，事务一旦提交，数据即被保存，数据库即使故障也不能遗失已经保存的数据

事务的原子性与隔离性都是服务于事务的一致性
即：原子性+隔离性  保障 一致性

数据库事务必须具有隔离性，同时隔离性被划分成了四个等级，四个等级的隔离也带来了相应的问题
未提交读    read uncommitted    脏读
已提交读    read committed    不可重复读
可重复读    repeatable read    幻读
序列化读    serializable    解决所有问题(执行效率最低，每个事务，每条语句，串行执行，无任何并发)

脏读：即事务在读取数据时能够读取到其他事务未提交的数据。
不可重复读：事务只能够读取其他事务已经提交的数据，问题在于如果读取同一行数据的事务在读取的同时有其他事务对该数据
进行了修改，那么该事务内如果有两次不同时间的对同一条数据的读取会导致读取同一行数据得到的结果不相同
幻读：可重复读隔离性能够确保事务读取的数据都被锁住，不允许其他事务对被读取的数据进行修改，但是，如果该事务存在范围查询
，那么如果在执行事务时，其他事务对该范围内的数据进行增添的话，会导致该事务在读取范围数据时得到多出于原先需要的数据，
即读到新插入的数据

插入数据的时候，含有多个values的语句和多个单values的语句，就性能上的对比来说，后者更快
要想优化存储过程，应该将多个要执行的语句包装进同一个事物中执行//减少连接时间


