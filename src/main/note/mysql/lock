mysql根据不同的实现引擎有不同的锁实现方式
innodb:
innodb提供了两种锁，读锁和写锁，即悲观锁和乐观锁。
使用update,delete,insert语句，innodb引擎自动上表锁(悲观)，如果需要使用行锁的话需要使用索引
使用select语句不会上锁(乐观)
但是mysql也提供了你在使用select语句时的上锁需求
在select语句的结尾添加 lock in share mode 会给查询数据上锁，允许其他数据读数据和上锁(lock in share mode)
问题在于如果使用该锁，使用这个锁的事务中有写任务的话，可能会因为其他事务对该数据的不断读取而造成死锁无法更新数据。

在select语句的结尾增加 for update 会使得该事务获得该表的表锁(悲观锁)

innodb引擎如果想实现行锁，需要提交的事务使用了索引查询(必须是数据库在执行查询时真实的使用了索引)，
这样才能使锁从表锁变成行锁

同时innodb引擎还在内部提供实现了意向锁，读意向锁和写意向锁(锁的粗放，更多的粒度)
读意向锁：IS 读锁:S    写意向锁:IX 写锁:X
事务在执行读或者写操作之前，必须先获得相对应的意向锁
数据库当前上在X锁模式时，所有事务都无法获得任何一种锁
在IX模式时，允许事务申请IS锁和IX锁
在S模式时允许事务申请S锁和IS锁
在IS模式时，允许事务申请IX，IS,S锁

隐式锁定：
innodb执行两段锁协议，即在需要加锁使才对数据进行加锁，在加锁之后只有在执行commit或者rollback时才释放所有锁
显示锁定：
在select句末加锁
