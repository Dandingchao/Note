mysql查询会在查询之前选择一条mysql认为最优的查询方案来进行查询(通过查询优化器选择)
查询优化器，目的在于尽可能的用最严格的索引方式搜索到需要的数据——即花费的时间尽可能的短

使用索引可以明显的加快查找速度
在数据量大的表查询中可以明显的看出使用索引的查询速度明显加快
索引的创建方式通常有B树和hash表

mysql使用B+树的数据结构，因为每次从磁盘读取数据都是一次IO，相比较于内存操作，耗费的时间更多，使用B+树的数据结构，一次性能读取整个B+树节点
的数据，每次读入更深的一层，都会进行一次IO，因此树的高度越低，性能越好。
非叶子节点只存key不存储数据，叶子节点只存储数据不存储key.
同时，由于一次读取的IO数据有限的原因，索引越小，那么一次性能够读取到的索引越多，通常能减少IO的次数

为什么不能滥用索引，因为索引本身也是存储在文件中，读取索引也是io操作，索引的作用是减少读取数据过程中的IO操作，如果因为索引使用不当
导致读取数据的过程中的IO操作增多，那么就本末倒置了。

索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句

索引的优点:
索引大大减小了服务器需要扫描的数据量
索引可以帮助服务器避免排序和临时表
索引可以将随机IO变成顺序IO
索引对于InnoDB（对索引支持行级锁）非常重要，因为它可以让查询锁更少的元组。在MySQL5.1和更新的版本中，InnoDB可以在服务器端过滤掉行后就释放锁，但在早期的MySQL版本中，InnoDB直到事务提交时才会解锁。对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即索引达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了。如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。
关于InnoDB、索引和锁：InnoDB在二级索引上使用共享锁（读锁），但访问主键索引需要排他锁（写锁）

缺点:
虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存索引文件。
建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。
如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。
对于非常小的表，大部分情况下简单的全表扫描更高效；

mysql在查询的过程中只会使用一个它认为最有效的索引

索引的建立要依赖在你使用的sql语句上建立，如果你的sql语句用不到你的索引，那建的索引没有任何意义。sql语句和索引搭配使用来减少
mysql的IO增大效率

mysql的索引上最左查询优先逻辑，即你设置了一个(name,age,address)的联合索引，事实上存在的索引为(name)/(name,age)/(name,age,address)
只会在使用到name的查询结构中才会使用这个索引，比如某个索引字段存在大量重复数据，这可能会导致索引没得卵用，然后数据库不用这个索引，或者用这索引
浪费了太多的时间。

mysql第一次搜索时会进行IO加载数据块和相关索引，消费的时间更长，在数据不更新的情况下，执行之前使用过的sql语句，mysql会从缓存中读取数据，
比第一次快

mysql使用索引有时会导致他的查询反而不如不用索引，如索引列数据大量重复，使用索引列进行范围查询。
mysql查询的更慢的一个原因是sending data消费大量时间，可能的原因：根据索引查询到的数据列中有些不在索引中，这会导致mysql使用行id继续
从数据库中重新读取数据，造成时间的消耗过大。innodb_buffer_pool_size过小，导致无法使用缓存，造成每次读取数据都从数据库中重新读。

sql_no_cache，关闭缓存